---
title: "How to Build a Basic QPSK modulator"
author: "Joey Reed"
date: "2024-11-27"
draft: false
summary: A quick and dirty introduction to QPSK modulation.
tags: ["communications", "digital modulation", "filters"]
jupyter: python3
format: hugo
math: true
---

*Quadrature Phase Shift Keying*, or QPSK for short, is a digital modulation technique that encodes information in a high frequency carrier signal by introducing phase shifts of $45^\circ$, $135^\circ$, $225^\circ$, or $315^\circ$ at a specified *symbol rate*.  Each phase shift is called a *symbol*.  For QPSK, a symbol is represented by 2 bits.  Higher order Quadrature Amplitude Modulation (QAM) schemes use more bits per symbol.

Phase shift keying (PSK) is the discrete time version of analog phase modulation.  Analog modulation predates the invention of integrated circuits, even transistors.  Analog modulators are built out of discrete components and tend to be simpler and consume less power than their digital counterparts.  However, digital modulators are programmed with processors, making them far more flexible and precise.    

## Derivation

The equation for phase modulating a carrier sitting at $f$ Hz with an information bearing baseband signal $\phi (t)$ is

$$
  y(t) = \cos(2\pi f t + \phi (t)).
$$

Turns out that this isn't a very helpful expression for developing a QPSK modulator because the carrier and baseband signals are intertwined.  If we can rip them apart, the baseband signal can be synthesized digitally and converted to an analog waveform at transmission time, using common and inexpensive circuit components.   

Fortunately, the fix is simple.  All we need is one of the angle sum formulas you probably learned in highschool:

$$
  \cos(x+y) = \cos(x)\cos(y) - \sin(x)\sin(y)
$$

If we apply this to $y(t)$, we get

$$
  y(t) = \cos (\phi (t))  \cos(2\pi f t) - \sin(\phi (t)) \sin(2\pi f t)
$$

I don't like all the parenthesis.  To clean it up, let's express this in terms of "I/Q modulation":

$$
  y(t) = I(t)  \cos(2\pi f t) - Q(t) \sin(2\pi f t)
$$

where $I(t)$ and $Q(t)$ are the so-called in-phase and quadrature signals.  These signals pop up frequently in digital communications, and in 
our particular case   

$$
    I(t) = \cos (\phi (t)) \text{ and } Q(t) = \sin(\phi(t)).
$$     

### What's the Point?


## Basic Simulation

Before we get started on the modulator, I want to comment on my programming style.  I like my modem simulations to be stupid simple.  No fancy programming-language magic or crazy abstractions allowed.  I want to be able to easily convert the simulation to a production-grade implementation in a  hardware description language (Verilog/System Verilog) or low-level programming language (C), without thinking too hard.   


The three most common packages I use for communications simulations are `numpy`, `matplotlib`, and `scipy`.  For this first one, we'll manage without `scipy`.     

```{python}

import numpy as np 
import matplotlib.pyplot as plt   

```

### From bits to complex symbols

First things first.  We need to choose a sequence of bits that will modulate the carrier.  I'm a big fan of using "hex-speak" for this sort of thing.  Hex-speak numbers are unsigned integers that also spell out words or phrases when expressed in hexadecimal (aka base 16 numbers).  Most of them are pretty funny, and just lighten the mood.  Here are a few of my favorites: `0xDEADBEEF`, `0xFEEDBABE`, `0xDECAFBAD`, `0xBADF00D`.  Let's combine them into one big hex-speak phrase and partition them into bytes:   

```{python}
payload = [
    0xDE, 0xAD, 0xBE, 0xEF, # DEADBEEF
    0xFE, 0xED, 0xBA, 0xBE, # FEEDBABE
    0xDE, 0xCA, 0xFB, 0xAD, # DECAFBAD
    0xBA, 0xAD, 0xF0, 0x0D  # BAADF00D
]
```

Now we convert the byte-array into a bit-array by looping over the bytes in `payload` and using bit-wise operations to extract the individual bits from each byte.  

```{python}
num_chars = len(payload)
num_bits = num_chars * 8
payload_bits = np.zeros(num_bits)
k = 0
for i in range(num_chars):
    byte = payload[i]
    for j in range(8):
        payload_bits[k] = 1 & (byte >> j)
        k += 1
```

Next, we convert the payload into an array of complex QPSK symbols.  We start by splitting up the big bit array into an even index bit (the in-phase array) array and an odd index bit array (the quadrature array).  


```{python}
i_bits = payload_bits[0::2]
q_bits = payload_bits[1::2]
```

With that out of the way, we map pairs of in-phase and quadrature bits to constellation points in the complex plane.  

```{python}
i_symbols = 2 * i_bits - 1
q_symbols = 2 * q_bits - 1

iq_symbols = i_symbols + 1j * q_symbols
```



### Pulse shaping 

In pulse shaping, we use a digital filter to convert the complex symbols into a smooth, fairly narrowband complex waveform.  Usually, the 
digital filter used for pulse shaping is referred to as a *matched filter*.          

```{python}

def root_raised_cosine(
    rate_i=1,       # Input sample rate
    rate_o=16,      # Ouput sample rate
    beta=0.5,       # Excess bandwidth parameter
    delay=5         # Number of symbol periods it takes for the peak to occur
):

    samples_per_symbol = rate_o // rate_i 

    n = int(samples_per_symbol * delay)
    x = []

    # Add first element
    x = x + [1 + beta * ((4/np.pi) - 1)]
    for i in range(1,n+1):
        if i == (samples_per_symbol/(4*beta)):
            sin_ = np.sin(np.pi/(4*beta))
            cos_ = np.cos(np.pi/(4*beta))
            c1  = (beta / np.sqrt(2))
            c2  = 1+(2/np.pi)
            c3  = 1-(2/np.pi)
            xi  = c1 * ((c2 * sin_) + (c3 * cos_))
        else:
            sin_ = np.sin(np.pi * i * (1-beta) / samples_per_symbol)
            cos_ = np.cos(np.pi * i * (1+beta) /samples_per_symbol)
            c1  = 4 * beta * i / samples_per_symbol 
            c2  = np.pi * (i / samples_per_symbol) * (1 - c1**2)  
            xi  = (sin_ + (c1 * cos_)) / c2

        x = [xi] + x + [xi]


    return np.array(x)

```



```{python}

iq_symbols_1 = np.zeros(16 * len(iq_symbols), dtype=complex)
iq_symbols_1[::16] = iq_symbols

``` 

```{python}

matched_filter = root_raised_cosine(1, 16, 0.5, 5)
```

```{python}
x0 = np.convolve(iq_symbols_1, matched_filter)
```

```{python}
delay = (len(matched_filter)-1)//2
plt.plot(np.real(x0))
plt.plot(np.concatenate((np.zeros(delay),np.real(iq_symbols_1))))
plt.xlim([0, 500])
```


### Frequency translation 


## Conclusion






